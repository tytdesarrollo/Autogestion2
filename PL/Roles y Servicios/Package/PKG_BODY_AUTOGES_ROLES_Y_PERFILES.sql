CREATE OR REPLACE PACKAGE BODY PKG_AUTOGES_ROLES_Y_PERFILES
 -- =============================================      
 -- Author:  FELIPE SATIZABAL
 -- =============================================
AS
-- =====================================================================
-- IDENTIFICAR SI TIENE ROL ESPECIAL
	FUNCTION FN_IDENTIF_ROL_ESPECIAL
	(
		V_CEDULA_EPL EMPLEADOS_BASIC.CEDULA%TYPE
	)
	RETURN VARCHAR2
	AS 
		CONTADOR_ROL_ESPC NUMBER; -- CONTADOR PARA IDENTIFICAR SI TIENE ASIGNADO UN ROL ESPECIAL
	BEGIN
		SELECT COUNT(*)
		INTO CONTADOR_ROL_ESPC
		FROM T_USUARIO_ROL_ESPECIAL
		WHERE COD_USUARIO_ESPECIAL = V_CEDULA_EPL;

		IF(CONTADOR_ROL_ESPC > 0) THEN
			RETURN 'ESPECIAL';
		ELSE 
			RETURN 'SIN_ROL';
		END IF;
	END FN_IDENTIF_ROL_ESPECIAL;

-- =====================================================================
-- IDENTIFICAR CUAL ES EL ROL PREDETERMINADO QUE TIENE ASIGNADO
	FUNCTION FN_IDENTIF_ROL_PREDETERMINADO
	(
		V_CEDULA_EPL EMPLEADOS_BASIC.CEDULA%TYPE
	)
	RETURN VARCHAR2
	AS
		-- VARIABLES PARA FILTRAR LA BUSQUEDA EN LOS ROLES DE TIPO SENA 
		GRU1 VARCHAR2(50) := 't_gru_sena';         -- GRUPO DE APRENDICES DEL SENA
		GRU2 VARCHAR2(50) := 't_gru_sena_prod';    -- GRUPO DE SENA EN ETAPA DE PRODUCCION
		GRU3 VARCHAR2(50) := 't_gru_sena_aut_ind'; -- GRUPO DE SENA NUEVOS

		SENTENCIA_SQL VARCHAR2(1000);			   -- SENTENCIA DE CADA ROL QUE SE EJECUTARA	
		CONTADOR_ROL NUMBER;					   -- CONTADOR PARA IDENTIFICAR EN QUE GRUPO DE ROL SE ENCUENTRA
	BEGIN
		-- ====================================================
		-- BLOQUE DEL ROL ADMINISTRADOR
		BEGIN
			SELECT SENTENCIA
			INTO SENTENCIA_SQL
			FROM T_ROLES
			WHERE COD_ROL = 4;

			SENTENCIA_SQL := 'SELECT COUNT(*) FROM DUAL WHERE :CEDULA IN ('||SENTENCIA_SQL||')';
			EXECUTE IMMEDIATE SENTENCIA_SQL INTO CONTADOR_ROL USING V_CEDULA_EPL;

			-- SI HAY RESULTADOS  EN LA BUSQUEDA RETORNA INDICANDO QUE PERTENECE AL ADMIN
			IF(CONTADOR_ROL > 0) THEN
				RETURN 'ADMIN';
			END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND
				THEN CONTADOR_ROL:= 0;
		END;

		-- ====================================================
		-- BLOQUE DEL ROL JEFE
		BEGIN
			SELECT SENTENCIA
			INTO SENTENCIA_SQL
			FROM T_ROLES
			WHERE COD_ROL = 3;

			SENTENCIA_SQL := 'SELECT COUNT(*) FROM DUAL WHERE :CEDULA IN ('||SENTENCIA_SQL||')';

			EXECUTE IMMEDIATE SENTENCIA_SQL INTO CONTADOR_ROL USING V_CEDULA_EPL;

			-- SI HAY RESULTADO EN LA BUSQUEDA RETORNA INDICANDO QUE PERTENECE AL SENA
			IF(CONTADOR_ROL > 0) THEN
				RETURN 'JEFE';
			END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND
				THEN CONTADOR_ROL:= 0;
		END;

		-- ===================================================
		-- BLOQUE DEL ROL RASO
		BEGIN
			SELECT SENTENCIA
			INTO SENTENCIA_SQL
			FROM T_ROLES
			WHERE COD_ROL = 2;

			SENTENCIA_SQL := 'SELECT COUNT(*) FROM DUAL WHERE :CEDULA IN ('||SENTENCIA_SQL||')';

			EXECUTE IMMEDIATE SENTENCIA_SQL INTO CONTADOR_ROL USING V_CEDULA_EPL;

			-- SI HAY RESULTADO EN LA BUSQUEDA RETORNA INDICANDO QUE PERTENECE AL SENA
			IF(CONTADOR_ROL > 0) THEN
				RETURN 'RASO';
			END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND
				THEN CONTADOR_ROL:= 0;
		END;

		-- ====================================================
		-- BLOQUE DEL ROL SENA
		BEGIN
			-- CONSULTA EL QUERY QUE TRAE TODAS LAS CEDULAS DE LOS EMPLEADOS CON ROL SENA
			SELECT SENTENCIA 
			INTO SENTENCIA_SQL
			FROM T_ROLES
			WHERE COD_ROL = 1;
			
			SENTENCIA_SQL := 'SELECT COUNT(*) FROM DUAL WHERE :CEDULA IN ('||SENTENCIA_SQL||')';
			EXECUTE IMMEDIATE SENTENCIA_SQL INTO CONTADOR_ROL USING V_CEDULA_EPL, GRU1, GRU2, GRU3;

			-- SI HAY RESULTADO EN LA BUSQUEDA RETORNA INDICANDO QUE PERTENECE AL SENA
			IF(CONTADOR_ROL > 0) THEN
				RETURN 'SENA';
			ELSE
				RETURN 'SIN_ROL';
			END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND
				THEN CONTADOR_ROL:= 0;
		END;	
	END FN_IDENTIF_ROL_PREDETERMINADO;

-- =====================================================================
-- ASINAR ROL ESPECIAL A UN EMPLEADO
	PROCEDURE SP_AUTOGES_ASIGNAR_ROLESPACIAL
	(
		V_IN_CEDULA_EMPLEADO IN EMPLEADOS_BASIC.CEDULA%TYPE,         -- 
		V_IN_COD_ROLESPECIAL IN T_ROL_ESPECIAL.COD_ROL_ESPECIAL%TYPE,
		V_OUT_MENSAJE OUT VARCHAR2
	)
	AS 
		EXISTE_ASIG NUMBER; -- IDENTIFICAR SI YA TIENE ASIGNADO UN ROL 
	BEGIN
		-- SI EXISTE EL EMPLEADO
		SELECT COUNT(*)	
		INTO EXISTE_ASIG
		FROM EMPLEADOS_BASIC
		WHERE CEDULA = V_IN_CEDULA_EMPLEADO;

		IF(EXISTE_ASIG >= 1) THEN
			BEGIN
				SELECT COUNT(*)
				INTO EXISTE_ASIG
				FROM T_USUARIO_ROL_ESPECIAL
				WHERE COD_USUARIO_ESPECIAL = V_IN_CEDULA_EMPLEADO;

				--SI EXISTE UN REGISTRO CON EL CODIGO SE ACTUALIZA SU ROL, DE LO CONTRARIO SE INSERTA SU NUEVO ROL
				IF(EXISTE_ASIG = 1) THEN
					BEGIN
						UPDATE T_USUARIO_ROL_ESPECIAL
						SET COD_ROL_ESPECIAL = V_IN_COD_ROLESPECIAL
						WHERE COD_USUARIO_ESPECIAL = V_IN_CEDULA_EMPLEADO;

						V_OUT_MENSAJE := 'El rol del usuario '||V_IN_CEDULA_EMPLEADO||' ha sido actualizado.';
					END;
				ELSE
					BEGIN
						INSERT INTO T_USUARIO_ROL_ESPECIAL
						VALUES (V_IN_CEDULA_EMPLEADO, V_IN_COD_ROLESPECIAL);

						V_OUT_MENSAJE := 'El rol ha sido asignado al usuario '||V_IN_CEDULA_EMPLEADO||'.';
					END;
				END IF;
			END;
		ELSE
			BEGIN
				V_OUT_MENSAJE := 'La usuario con cedula '||V_IN_CEDULA_EMPLEADO||' no se encuentra registrado en nomina.';
			END;
		END IF;
	END SP_AUTOGES_ASIGNAR_ROLESPACIAL;

-- =====================================================================
-- CREAR ROL ESPECIAL
	PROCEDURE SP_AUTOGES_CREAR_ROLESPECIAL
	(
		V_IN_NOMBRE_ROL IN VARCHAR2,  -- NOMBRE DEL ROL ESPECIAL A CREAR
		V_IN_DESCRIPCION IN VARCHAR2, -- DESCRIPCION DEL ROL
		V_IN_SUBMENUS IN VARCHAR2, 	  -- SUBMENUS ASIGANADAS AL ROL QUE SE CREA
		V_OUT_MENSAJE OUT VARCHAR2	  -- MENSAJE DE LA ACCION OCURRIDA
	)
	AS
		CODIGO_ROL_CREADO NUMBER;         --CODIGO ASIGNADO AL ROL QUE SE CREA 
		ARRAY_DATOS ARRAY_DE_DATOS_TYPE;  -- CODIGOS DE LOS SUBMENUS ASIGNADOS AL ROL 
		CANTIDAD_DATOS NUMBER;			  -- CANTIDAD DE DATOS EN ARRAY
		EXISTE_SUBMENUS NUMBER;			  -- CANTIDAD DE SUBMENUS CORRECTOS A LS INGRESADOS
		SENTENCIA_SQL VARCHAR(1000);      -- SENTENCIA SQL PARA VALIDAR CODIGOS
	BEGIN
		-- SEPARAMOS LOS DATOS Y SE ALMACENAN EN UN ARRAY
		SP_AUTOGES_SUBMENUS_ASIGNADOS(V_IN_SUBMENUS,ARRAY_DATOS,CANTIDAD_DATOS);

		-- SE COMPRUEBA QUE LOS CODIGOS INGRESADOS SON VALIDOS
		SENTENCIA_SQL := 'SELECT COUNT(*) FROM T_SUB_MENU WHERE COD_SUB_MENU IN ('||V_IN_SUBMENUS||')';
		EXECUTE IMMEDIATE SENTENCIA_SQL INTO EXISTE_SUBMENUS;

		IF(EXISTE_SUBMENUS <> CANTIDAD_DATOS) THEN
			BEGIN
				V_OUT_MENSAJE := 'Algun(os) codigo(s) no coincide(n) con los submenus existentes';
			END;
		ELSE
			BEGIN			
				-- CREAR EL ROL
				INSERT INTO T_ROL_ESPECIAL (
					NOM_ROL_ESPECIAL, DESCRIPCION)
				VALUES (
					V_IN_NOMBRE_ROL, V_IN_DESCRIPCION);
				-- CODIGO ASIGNADO AL ROL CREADO
				SELECT MAX(COD_ROL_ESPECIAL) 
				INTO CODIGO_ROL_CREADO 
				FROM T_ROL_ESPECIAL;
				-- INSERTAMS LOS SUBMENUS ASIGNADOS AL ROL CREADO
				FOR I IN 1..CANTIDAD_DATOS
				LOOP
					INSERT INTO T_REL_SUBMENU_ESPECIAL
					VALUES(CODIGO_ROL_CREADO,ARRAY_DATOS(I));
				END LOOP;

				V_OUT_MENSAJE := 'Rol especial creado correctamente';
			END;
		END IF;
	END SP_AUTOGES_CREAR_ROLESPECIAL;

-- =====================================================================
-- DETALLE DE LOS ROLES ESPECIALES CREADOS
	PROCEDURE SP_AUTOGES_DETALLE_ROLESPECIAL
	(
		V_OUT_ROLES_SUBMENUS OUT SYS_REFCURSOR
	)
	AS 
	BEGIN
		OPEN V_OUT_ROLES_SUBMENUS FOR
			SELECT TRE.COD_ROL_ESPECIAL COD_ROL, TRE.NOM_ROL_ESPECIAL NOM_ROL, 
			    TSM.COD_SUB_MENU CODIGO_SUBMENU, TSM.NOM_SUB_MENU NM_SUBMENU  
			FROM T_SUB_MENU TSM
			INNER JOIN T_REL_SUBMENU_ESPECIAL TRSE
			    ON TRSE.T_SUB_MENU = TSM.COD_SUB_MENU
			INNER JOIN T_ROL_ESPECIAL TRE
			    ON TRE.COD_ROL_ESPECIAL = TRSE.COD_ROL_ESPECIAL
			ORDER BY TRE.NOM_ROL_ESPECIAL,TSM.COD_SUB_MENU;
	END SP_AUTOGES_DETALLE_ROLESPECIAL;

-- =====================================================================
-- ITEMS ASIGNADOS A UN ROL ESPECUAL
	PROCEDURE SP_AUTOGES_MENUITEM_ESPECIAL
	(
		V_IN_CEDULA_EPL IN EMPLEADOS_BASIC.COD_EPL%TYPE,
		V_OUT_MENU OUT SYS_REFCURSOR
	)
	AS
		ITEM_MENU NUMBER;				 -- DATOS DEVUELTOS EN EL CURSOR
		CURSOR CURSOR_MENU_COD IS 		 -- CODIGOS DE TODOS LOS MENUS EXISTENTES
			SELECT COD_MENU
			FROM T_MENU;
		CURSOR CURSOR_MENU IS 		     -- CURSOR CONSULTA ITEM DE MENU ASIGNADOS AL ROL ESPECIAL
			SELECT DISTINCT TSM.COD_MENU MENU
			FROM T_SUB_MENU TSM
			INNER JOIN T_REL_SUBMENU_ESPECIAL TRSE
			    ON TSM.COD_SUB_MENU = TRSE.T_SUB_MENU  
			INNER JOIN T_USUARIO_ROL_ESPECIAL TURE
			    ON TURE.COD_ROL_ESPECIAL = TRSE.COD_ROL_ESPECIAL
			    AND TURE.COD_ROL_ESPECIAL IN (SELECT COD_ROL_ESPECIAL
						                      FROM T_USUARIO_ROL_ESPECIAL TURE
						                      WHERE TURE.COD_USUARIO_ESPECIAL = V_IN_CEDULA_EPL);
	BEGIN
		-- INSERTO TODOS LOS MENUS EN FALSO
		OPEN CURSOR_MENU_COD;
		
		LOOP
			FETCH CURSOR_MENU_COD INTO ITEM_MENU;
			EXIT WHEN CURSOR_MENU_COD%NOTFOUND;		

			INSERT INTO TT_MENU VALUES(ITEM_MENU,'FALSE');
		END LOOP;

		CLOSE CURSOR_MENU_COD;

		-- ACTUALIZO LOS MENUS QUE ESTAN ASIGNADOS AL ROL EN VERDADERO
		OPEN CURSOR_MENU;	

		LOOP
			FETCH CURSOR_MENU INTO ITEM_MENU;
			EXIT WHEN CURSOR_MENU%NOTFOUND;

			UPDATE TT_MENU 
			SET VALOR = 'TRUE'
			WHERE MENU = ITEM_MENU;		
		END LOOP;

		CLOSE CURSOR_MENU;

		-- CONSULTO LOS DATOS EN LA TABLA TEMPORAL ASIGNANDOLOS EN LA VARIABLE DE SALIDA
		OPEN V_OUT_MENU FOR
			SELECT TTM.MENU,TM.NOM_MENU,TTM.VALOR
			FROM T_MENU TM
			INNER JOIN TT_MENU TTM
				ON TTM.MENU = TM.COD_MENU;
	END SP_AUTOGES_MENUITEM_ESPECIAL;

-- =====================================================================
-- ITEMS ASIGNADOS A UN ROL PREDETERMINADO
	PROCEDURE SP_AUTOGES_MENUITEM_PREDETERM
	(
		V_IN_ROL_EPL IN VARCHAR2,
		V_OUT_MENU OUT SYS_REFCURSOR
	)
	AS
		ITEM_MENU NUMBER;				 -- DATOS DEVUELTOS EN EL CURSOR
		CURSOR CURSOR_MENU_COD IS 		 -- CODIGOS DE TODOS LOS MENUS EXISTENTES
			SELECT COD_MENU
			FROM T_MENU;
		CURSOR CURSOR_MENU IS 		     -- CURSOR CONSULTA ITEM DE MENU ASIGNADOS AL ROL ESPECIAL
			SELECT DISTINCT TSM.COD_MENU MENU
			FROM T_SUB_MENU TSM
			INNER JOIN T_RELACION_MENU_ROL TRMR
			    ON TSM.COD_SUB_MENU = TRMR.COD_SUB_MENU  
			INNER JOIN T_ROLES TR
	            ON TR.COD_ROL = TRMR.COD_ROL
			    AND TR.TIPO_ROL = V_IN_ROL_EPL;
	BEGIN
		-- INSERTO TODOS LOS MENUS EN FALSO
		OPEN CURSOR_MENU_COD;
		
		LOOP
			FETCH CURSOR_MENU_COD INTO ITEM_MENU;
			EXIT WHEN CURSOR_MENU_COD%NOTFOUND;		

			INSERT INTO TT_MENU VALUES(ITEM_MENU,'FALSE');
		END LOOP;

		CLOSE CURSOR_MENU_COD;

		-- ACTUALIZO LOS MENUS QUE ESTAN ASIGNADOS AL ROL EN VERDADERO
		OPEN CURSOR_MENU;	

		LOOP
			FETCH CURSOR_MENU INTO ITEM_MENU;
			EXIT WHEN CURSOR_MENU%NOTFOUND;

			UPDATE TT_MENU 
			SET VALOR = 'TRUE'
			WHERE MENU = ITEM_MENU;		
		END LOOP;

		CLOSE CURSOR_MENU;

		-- CONSULTO LOS DATOS EN LA TABLA TEMPORAL ASIGNANDOLOS EN LA VARIABLE DE SALIDA
		OPEN V_OUT_MENU FOR
			SELECT TTM.MENU,TM.NOM_MENU,TTM.VALOR
			FROM T_MENU TM
			INNER JOIN TT_MENU TTM
				ON TTM.MENU = TM.COD_MENU;
	END SP_AUTOGES_MENUITEM_PREDETERM;

-- =====================================================================
-- SUBITEMS ASIGNADOS A UN ROL PREDETERMINADO
	PROCEDURE SP_AUTOGES_SUBMENUITEM_PREDETE
	(
		V_IN_ROL_EPL IN VARCHAR2,
		V_OUT_SUBMENU OUT SYS_REFCURSOR
	)
	AS
		ITEM_MENU NUMBER;				 -- DATOS DEVUELTOS EN EL CURSOR
		CURSOR CURSOR_SUBMENU_COD IS 		 -- CODIGOS DE TODOS LOS MENUS EXISTENTES
			SELECT COD_SUB_MENU 
			FROM T_SUB_MENU;   
		CURSOR CURSOR_SUBMENU IS		 -- CURSOR CONSULTA ITEM DE SUBMENU ASIGNADOS AL ROL ESPECIAL
			SELECT TSM.COD_SUB_MENU
			FROM T_SUB_MENU TSM 	
			INNER JOIN T_RELACION_MENU_ROL TRMR
			    ON TSM.COD_SUB_MENU = TRMR.COD_SUB_MENU  
			INNER JOIN T_ROLES TR
	            ON TR.COD_ROL = TRMR.COD_ROL
	            AND TR.TIPO_ROL = V_IN_ROL_EPL;
	BEGIN
		-- INSERTO TODOS LOS MENUS EN FALSO
		OPEN CURSOR_SUBMENU_COD;
		
		LOOP
			FETCH CURSOR_SUBMENU_COD INTO ITEM_MENU;
			EXIT WHEN CURSOR_SUBMENU_COD%NOTFOUND;		

			INSERT INTO TT_SUBMENU VALUES(ITEM_MENU,'FALSE');
		END LOOP;

		CLOSE CURSOR_SUBMENU_COD;

		-- ACTUALIZO LOS SUBMENUS QUE ESTAN ASIGNADOS AL ROL EN VERDADERO
		OPEN CURSOR_SUBMENU;	

		LOOP
			FETCH CURSOR_SUBMENU INTO ITEM_MENU;
			EXIT WHEN CURSOR_SUBMENU%NOTFOUND;

			UPDATE TT_SUBMENU 
			SET VALOR = 'TRUE'
			WHERE SUBMENU = ITEM_MENU;		
		END LOOP;

		CLOSE CURSOR_SUBMENU;

		OPEN V_OUT_SUBMENU FOR
			SELECT TTS.SUBMENU,TSM.NOM_SUB_MENU,TTS.VALOR
			FROM T_SUB_MENU TSM
			INNER JOIN TT_SUBMENU TTS
				ON TTS.SUBMENU = TSM.COD_SUB_MENU;	
	END SP_AUTOGES_SUBMENUITEM_PREDETE;

-- =====================================================================
-- SUBITEMS ASIGNADOS A UN ROL ESPECIAL
	PROCEDURE SP_AUTOGES_SUBMENUITEM_SPECIAL
	(
		V_IN_CEDULA_EPL IN EMPLEADOS_BASIC.COD_EPL%TYPE,
		V_OUT_SUBMENU OUT SYS_REFCURSOR
	)
	AS
		ITEM_MENU NUMBER;				 -- DATOS DEVUELTOS EN EL CURSOR
		CURSOR CURSOR_SUBMENU_COD IS 		 -- CODIGOS DE TODOS LOS MENUS EXISTENTES
			SELECT COD_SUB_MENU 
			FROM T_SUB_MENU;   
		CURSOR CURSOR_SUBMENU IS		 -- CURSOR CONSULTA ITEM DE SUBMENU ASIGNADOS AL ROL ESPECIAL
			SELECT TRSE.T_SUB_MENU
			FROM T_REL_SUBMENU_ESPECIAL TRSE 	
			INNER JOIN T_ROL_ESPECIAL TRE
			    ON TRE.COD_ROL_ESPECIAL = TRSE.COD_ROL_ESPECIAL
			INNER JOIN T_USUARIO_ROL_ESPECIAL TURE
			    ON TURE.COD_ROL_ESPECIAL = TRE.COD_ROL_ESPECIAL
			    AND TURE.COD_USUARIO_ESPECIAL = V_IN_CEDULA_EPL;
	BEGIN
		-- INSERTO TODOS LOS MENUS EN FALSO
		OPEN CURSOR_SUBMENU_COD;
		
		LOOP
			FETCH CURSOR_SUBMENU_COD INTO ITEM_MENU;
			EXIT WHEN CURSOR_SUBMENU_COD%NOTFOUND;		

			INSERT INTO TT_SUBMENU VALUES(ITEM_MENU,'FALSE');
		END LOOP;

		CLOSE CURSOR_SUBMENU_COD;

		-- ACTUALIZO LOS SUBMENUS QUE ESTAN ASIGNADOS AL ROL EN VERDADERO
		OPEN CURSOR_SUBMENU;	

		LOOP
			FETCH CURSOR_SUBMENU INTO ITEM_MENU;
			EXIT WHEN CURSOR_SUBMENU%NOTFOUND;

			UPDATE TT_SUBMENU 
			SET VALOR = 'TRUE'
			WHERE SUBMENU = ITEM_MENU;		
		END LOOP;

		CLOSE CURSOR_SUBMENU;

		OPEN V_OUT_SUBMENU FOR
			SELECT TTS.SUBMENU,TSM.NOM_SUB_MENU,TTS.VALOR
			FROM T_SUB_MENU TSM
			INNER JOIN TT_SUBMENU TTS
				ON TTS.SUBMENU = TSM.COD_SUB_MENU;	
	END SP_AUTOGES_SUBMENUITEM_SPECIAL;

-- =====================================================================
-- SUBITEMS QUE SE ASIGNAN A UN ROL ESPECIAL CREADO
	PROCEDURE SP_AUTOGES_SUBMENUS_ASIGNADOS
	(
		V_IN_DATOS IN VARCHAR2,		    	-- VARIABLE QUE CONTIENE TODOS LOS DATOS INSERTADOS SEPARADOS POR COMAS
		ARRAY_DATOS OUT ARRAY_DE_DATOS_TYPE,
		V_OUT_NUM_DATOS  OUT NUMBER
	)
	AS
		POSICION NUMBER := 1;				    -- POSICION DONDE ARRANCA A LEER LOS DATOS
	    DATOS_ING VARCHAR2(1000) := V_IN_DATOS; -- CADENA DE DATOS SEPARADOS POR COMAS (,)
	    DATOS_CON VARCHAR2(1000) := V_IN_DATOS; -- CADENA PARA CALCULAR TAMANO
	    CONTADOR NUMBER := 1;				    -- POSICION DEL ARRAY PARA GRABAR LOS DATOS
	    TAMANO_ARRAY NUMBER;					-- TAMANO DEL ARRAY DE DATOS A RETORNAR
	BEGIN
		-- CALCULAMOS EL TAMAñO QUE VA A TENER EL ARRAY 
		TAMANO_ARRAY := LENGTH(DATOS_CON) - LENGTH(REPLACE(DATOS_CON,',')) + 1;
		V_OUT_NUM_DATOS := TAMANO_ARRAY;
		-- DECLARAMOS EL TAMAñO DEL ARRAY 
		ARRAY_DATOS := ARRAY_DE_DATOS_TYPE();
	    ARRAY_DATOS.EXTEND(TAMANO_ARRAY);

	    -- CICLO DE LLENADO DEL ARRAY 
		LOOP
			IF(INSTR(DATOS_ING,',') = 0) THEN
				BEGIN
					ARRAY_DATOS(CONTADOR) := SUBSTR(DATOS_ING,1);
					EXIT;
				END;
			ELSE
				BEGIN
					POSICION := INSTR (DATOS_ING, ',') - 1;
				END;
			END IF;
			ARRAY_DATOS(CONTADOR) := SUBSTR (DATOS_ING, 1, POSICION);
			DATOS_ING := SUBSTR(DATOS_ING,POSICION+2);
			CONTADOR:= CONTADOR +1;
		END LOOP;
	END SP_AUTOGES_SUBMENUS_ASIGNADOS;	
END PKG_AUTOGES_ROLES_Y_PERFILES;